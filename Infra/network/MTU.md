---
id: 1767336715-ANKM
aliases:
  - MTU
tags: []
---

**Fundamental Rationale:** MTU는 물리적 오류 확률과 네트워크 지연(Latency) 사이의 균형점을 찾기 위해 설정된 물리 계층의 제약이며, 현대에도 이를 함부로 늘리지 못하는 이유는 인터넷이라는 거대한 분산 시스템의 '가장 좁은 병목 구간(Weakest Link)'이 전체 통신 규격을 결정하기 때문입니다.

---

### 1. MTU (Maximum Transmission Unit)의 본질: 데이터의 '화물 트럭'

**MTU는 네트워크 인터페이스가 한 번에 보낼 수 있는 가장 큰 데이터 패킷의 크기(바이트 단위)입니다.**
단순히 "최대 크기"라고 이해하면 안 됩니다. 이것은 **하드웨어와 프로토콜이 합의한 물리적 한계선**입니다.

이더넷(Ethernet) 환경에서 표준 MTU는 **1500 바이트**입니다.

#### 논리적 구조 분해 (Low-Level View)

데이터가 전송될 때 순수한 데이터(Payload)만 가는 것이 아닙니다. 택배를 보낼 때 상자(Header)가 필요하듯, 오버헤드가 붙습니다.

* **Ethernet Frame:** [ Preamble | Destination MAC | Source MAC | Type | **Payload (MTU 영역)** | FCS ]
* **MTU (1500 bytes) 내부:** [ IP Header (20B) | TCP Header (20B) | **순수 데이터 (1460B)** ]

> **핵심:** MTU가 1500바이트라는 말은, 실제로 실어 나를 수 있는 **유효 데이터(Payload)**는 TCP/IP 헤더(최소 40바이트)를 뺀 **1460바이트**라는 뜻입니다.

---

### 2. 왜 1500바이트인가? (과거의 물리적 제약)

"1500바이트는 너무 작지 않나?"라는 질문은 타당합니다. 하지만 이 숫자는 1980년대 초반 이더넷이 처음 설계될 때의 **물리적 한계와 확률론**에 의해 결정되었습니다.

1. **전송 오류 확률 (Bit Error Rate):**
* 당시 구리선(Coaxial Cable)은 노이즈에 취약했습니다.
* 패킷이 길수록 전송 중에 비트 하나가 깨질 확률이 급격히 높아집니다.
* 패킷의 1비트만 깨져도 전체 패킷을 버리고 **재전송(Retransmission)**해야 합니다. 1500바이트는 재전송 비용과 오버헤드 사이의 **타협점(Sweet Spot)**이었습니다.


2. **직렬화 지연 (Serialization Delay):**
* 10Mbps 네트워크에서 1500바이트를 전선에 쏘는 데 걸리는 시간:


* 만약 패킷이 64KB(65,535바이트)라면? 약 **52ms**가 걸립니다.
* 네트워크는 공유 자원입니다. 내가 큰 데이터를 보내는 동안, 다른 사람의 긴급한 패킷(예: VoIP, 게임 핑)은 52ms 동안 대기해야 합니다. 이를 **Head-of-Line Blocking**이라 하며, 실시간성을 해칩니다.


3. **버퍼 메모리 비용:**
* 초기 라우터/스위치의 메모리는 매우 비쌌습니다. 큰 패킷을 처리하려면 그만큼 큰 버퍼가 필요했습니다.



---

### 3. 현대에는 늘려도 되지 않나? (Jumbo Frames와 현실의 벽)

현대 네트워크(1Gbps, 10Gbps 이상)와 광케이블 환경에서는 오류율이 극히 낮고, 전송 속도도 빠릅니다. 그래서 **Jumbo Frame (9000 바이트)** 기술이 이미 존재합니다.

**하지만 인터넷 전체(WAN)에는 적용하지 못합니다. 그 이유는 '경로의 파편화' 때문입니다.**

#### 시나리오: 당신이 9000 바이트 패킷을 보낸다고 가정합시다.

1. **내 PC (MTU 9000)  내 공유기 (MTU 9000):** 성공.
2. **내 공유기  통신사 라우터 (MTU 9000):** 성공.
3. **통신사 라우터  해외 해저 케이블 구간의 어떤 오래된 라우터 (MTU 1500):** **충돌 발생!**

이때 두 가지 재앙 중 하나가 일어납니다.

* **Case A: 단편화 (Fragmentation):**
* 라우터가 9000바이트 패킷을 받아서 1500바이트 조각 6개로 쪼갭니다.
* **문제점:** 라우터의 CPU 부하가 폭증합니다(SW 처리). 또한, 조각난 6개 중 하나만 유실되어도 전체 9000바이트를 다시 보내야 합니다. 효율이 급락합니다.


* **Case B: 패킷 폐기 (Drop) & PMTUD 실패:**
* 대부분의 고성능 라우터는 단편화 기능을 끕니다(`DF bit` 설정).
* 라우터는 패킷을 버리고 "너무 커!"라는 ICMP 메시지를 보내야 하는데, 보안 방화벽이 이 ICMP를 차단하는 경우가 많습니다(Black Hole Router 문제).
* 결과적으로 **연결은 되었는데 데이터 전송만 안 되는(Hang)** 현상이 발생합니다.



---

### 4. 데이터 변환 과정 시각화 (State Transformation)

1GB(1,073,741,824 바이트) 파일을 전송한다고 가정할 때, MTU 크기에 따른 시스템 부하 차이를 비교합니다.

| 구분 | 표준 이더넷 (MTU 1500) | 점보 프레임 (MTU 9000) | 비고 |
| --- | --- | --- | --- |
| **Payload 크기** | 1,460 바이트 | 8,960 바이트 | TCP/IP 헤더 40B 제외 |
| **필요 패킷 수** | 약 735,440 개 | 약 119,838 개 | 패킷 수가 **1/6**로 감소 |
| **헤더 오버헤드** | 약 29.4 MB | 약 4.8 MB | 낭비되는 데이터 감소 |
| **인터럽트 횟수** | 735,440 회 | 119,838 회 | CPU가 패킷 처리를 위해 깨어나는 횟수 |

**결론:**
데이터센터 내부(LAN, SAN)나 AWS VPC 내부처럼 **모든 경로를 통제할 수 있는 곳**에서는 MTU 9000을 씁니다. 하지만 **통제 불가능한 인터넷(WAN)**에서는 호환성을 위해 1500을 준수해야 합니다.

---

### Reverse Teaching (검증)

사용자의 이해도를 확인하기 위해 다음 상황을 분석하여 내 논리적 허점을 찾아내거나, 상황을 설명해 보십시오.

> **상황:** 당신은 회사 내부망(LAN)을 관리하는 엔지니어입니다. 모든 스위치와 서버의 MTU를 9000으로 설정하여 대용량 DB 백업 속도를 높였습니다. 그런데, 어떤 직원이 "외부 인터넷 웹사이트 접속이 너무 느리거나, 특정 사이트는 아예 안 열린다"고 불만을 토로합니다.
> **질문:**
> 1. 내부망 MTU를 9000으로 올렸는데, 왜 외부 인터넷 접속에 문제가 생길까요? (단편화 관점에서 설명)
> 2. 이 문제를 해결하기 위해 PC(클라이언트)의 MTU 설정을 어떻게 바꿔야 하며, 그 이유는 무엇입니까?
> 
>
