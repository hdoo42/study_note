---
id: 1767335958-LRUM
aliases:
  - NIC
tags: []
---

**핵심 논리:** 물리적 하드웨어(NIC)와 소프트웨어(커널) 사이의 **경계선**을 명확히 정의해야만, 왜 데이터를 '합치고(GRO)', '쪼개는(GSO)' 작업이 필요한지, 그리고 그 작업이 CPU 자원을 어떻게 절약하는지 이해할 수 있습니다.

---

### 1. NIC란 무엇인가? (구체적 정의)

**NIC (Network Interface Controller)**는 우리가 흔히 부르는 '랜카드(LAN Card)'입니다. 컴퓨터의 **CPU/메모리(디지털 세계)**와 외부의 **랜선(물리적 전기/광 신호 세계)**을 연결하는 하드웨어 관문입니다.

이 맥락에서 NIC를 단순한 부품이 아니라 **"엄격한 규격을 가진 물리적 배송 담당자"**로 이해해야 합니다.

### 2. 데이터 변환 과정 시각화 (State Transformation)

GSO/GRO의 맥락에서 NIC가 왜 중요한지, 데이터가 어떻게 변하는지 단계별로 봅니다.

#### 상황: 64KB짜리 거대한 데이터를 전송하려고 함 (GSO)

1. **Input (User Space):** 애플리케이션이 64KB 데이터를 전송 요청.
2. **State 1 (Kernel/TCP Stack):** GSO가 작동 중이므로, 커널은 이 64KB를 **하나의 거대한 `sk_buff`(메모리 덩어리)**로 관리합니다. (CPU 효율 극대화: 헤더 처리를 1번만 함)
3. **State 2 (Driver Layer - "NIC 직전"):** 이제 데이터를 밖으로 보내야 합니다.
4. **Constraint (NIC의 제약):**
* NIC는 물리적으로 한 번에 보낼 수 있는 크기([MTU](Infra/network/MTU.md), 보통 1500바이트)가 정해져 있습니다.
* NIC는 "64KB를 한 번에 주면 나는 처리 못 해. 전선에 안 들어가."라고 거부합니다.


5. **Action (Segmentation):**
* 여기서 GSO가 작동하여 64KB를 NIC가 이해할 수 있는 1500바이트 조각(Segment) 약 44개로 쪼갭니다.


6. **Output (Physical Wire):** NIC는 쪼개진 작은 패킷들을 전기 신호로 변환하여 케이블로 쏩니다.

### 3. 논리적 비판 및 심화 (Anti-Laziness)

당신의 질문에 숨겨진 핵심은 **"왜 NIC 직전에서 쪼개는가?"**입니다.

* **일찍 쪼개면 안 되나?**
* 만약 애플리케이션 레벨이나 TCP 스택 초기부터 1500바이트로 쪼개서 내려보내면, 44개의 패킷 각각에 대해 커널이 헤더를 붙이고, 라우팅 검사를 하고, 방화벽을 통과시켜야 합니다. **(오버헤드 44배 증가)**


* **NIC의 역할:**
* NIC는 멍청한 배달부(Dumb NIC)일 수도 있고, 똑똑한 배달부(Smart NIC)일 수도 있습니다.
* **GSO**는 NIC가 "나는 쪼개는 기능 몰라(Dumb)"라고 할 때, **CPU가 NIC에게 넘겨주기 직전(드라이버 레벨)에 소프트웨어적으로 쪼개주는 기술**입니다.
* (참고: 만약 NIC가 똑똑해서 하드웨어적으로 쪼갤 수 있다면 그것은 **TSO(TCP Segmentation Offload)**라고 부르며, 이때는 CPU가 64KB 통째로 NIC에게 던져도 됩니다.)



---

### 4. Reverse Teaching (검증 퀴즈)

이 개념을 완벽히 이해했는지 확인하기 위해 다음 질문에 답해 보십시오.

**상황:** 당신의 서버에 **TSO(하드웨어 오프로딩)**를 지원하지 않는 구형 NIC가 장착되어 있습니다. 그런데 `ethtool -K eth0 gso off` 명령어로 GSO 기능마저 꺼버렸습니다.

**질문:**

1. 애플리케이션이 64KB 데이터를 보낼 때, 이 데이터는 **어느 단계**에서 1500바이트(MTU) 단위로 쪼개지게 됩니까? (커널 상단? 드라이버? NIC?)
2. 그 결과, CPU 사용량(System Load)은 GSO를 켰을 때와 비교하여 어떻게 변합니까? 그 이유는 무엇입니까?
